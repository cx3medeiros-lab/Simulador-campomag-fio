<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador de Campo Magnético</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; touch-action: none; }
        
        #ui { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(20, 20, 20, 0.9); 
            padding: 12px; 
            border-radius: 8px; 
            border: 1px solid #444; 
            width: 260px; /* Reduzi um pouco a largura padrão */
            z-index: 100; 
            color: white;
        }

        /* AJUSTE AGRESSIVO PARA MOBILE */
        @media (max-width: 480px) { 
            #ui { 
                width: 220px; /* Painel bem mais estreito */
                padding: 8px;
                font-size: 14px;
            }
            h3 { font-size: 16px !important; margin-bottom: 5px !important; }
            label { font-size: 14px !important; }
            .formula { font-size: 1.1em !important; padding: 5px !important; }
            #valor-h { font-size: 18px !important; }
            #label-texto { font-size: 12px !important; }
        }

        .control { margin-bottom: 8px; }
        label { display: block; color: #ccc; margin-bottom: 3px; }
        input[type=range] { width: 100%; height: 25px; cursor: pointer; }
        h3 { margin: 0 0 10px 0; color: #00d4ff; border-bottom: 1px solid #333; }
        .formula { 
            font-family: serif; color: #ffcc00; text-align: center; 
            background: rgba(255,255,255,0.05); border-radius: 4px; margin: 5px 0;
        }
        #valor-h { text-align: center; font-weight: bold; color: #00ffaa; }
        #label-texto { color: #00ffff; margin-top: 5px; border-top: 1px solid #333; padding-top: 5px; text-align: center; line-height: 1.2; }
    </style>
</head>
<body>

<div id="ui">
    <h3>Campo Magnético H</h3>
    <div class="control">
        <label id="label-i">Corrente (i): 5 A</label>
        <input type="range" id="input-i" min="-20" max="20" step="0.5" value="5">
    </div>
    <div class="control">
        <label id="label-r">Distância (r): 1.0 m</label>
        <input type="range" id="input-r" min="0" max="4" step="0.01" value="1">
    </div>
    <div id="formula-display" class="formula">H = i / (2πr)</div>
    <div id="valor-h">H = 0.80 A/m</div>
    <div id="label-texto">Setas tangentes indicam o sentido do campo H</div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
    let scene, camera, renderer, wire, currentArrow, fieldCylinder;
    const rings = [];
    const tangentArrows = [];
    const R_FIO = 0.12; 

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        
        // AJUSTE DE CÂMERA: Se a tela for estreita (celular), movemos o alvo da câmera para a direita
        if (aspect < 1) {
            camera.position.set(4, 5, 8); // Ângulo mais inclinado
            camera.lookAt(-1.5, 0, 0);   // "Empurra" o fio para a esquerda para não ficar sob o menu
        } else {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
        }

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita para não pesar em celulares 4K
        document.body.appendChild(renderer.domElement);

        const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
        light1.position.set(5, 10, 7);
        scene.add(light1);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        wire = new THREE.Mesh(
            new THREE.CylinderGeometry(R_FIO, R_FIO, 15, 16),
            new THREE.MeshStandardMaterial({ color: 0x9c5221, metalness: 0.8, roughness: 0.3 })
        );
        scene.add(wire);

        currentArrow = new THREE.Mesh(
            new THREE.ConeGeometry(0.18, 0.5, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(currentArrow);

        fieldCylinder = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 10, 32, 1, true),
            new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        scene.add(fieldCylinder);

        for (let i = 0; i < 6; i++) {
            const yPos = (i - 2.5) * 2;
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(1, 0.02, 8, 64),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true })
            );
            ring.rotation.x = Math.PI / 2;
            ring.position.y = yPos;
            scene.add(ring);
            rings.push(ring);

            const arrowGrp = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            stem.rotation.z = Math.PI / 2;
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            head.position.x = 0.25; head.rotation.z = -Math.PI / 2;
            arrowGrp.add(stem, head);
            arrowGrp.position.y = yPos;
            scene.add(arrowGrp);
            tangentArrows.push(arrowGrp);
        }

        setupControls();
        animate();
    }

    function setupControls() {
        const inputI = document.getElementById('input-i');
        const inputR = document.getElementById('input-r');
        const update = () => {
            const i = parseFloat(inputI.value);
            const r = parseFloat(inputR.value);
            let h = (r >= R_FIO) ? i / (2 * Math.PI * r) : (i * r) / (2 * Math.PI * (R_FIO**2));
            if (r === 0) h = 0;

            document.getElementById('formula-display').innerText = r >= R_FIO ? "H = i / (2πr)" : "H = (i·r)/(2πR²)";
            document.getElementById('label-i').innerText = `Corrente (i): ${i} A`;
            document.getElementById('label-r').innerText = `Distância (r): ${r.toFixed(2)} m`;
            document.getElementById('valor-h').innerText = `H = ${Math.abs(h).toFixed(2)} A/m`;

            currentArrow.position.y = i >= 0 ? 1.5 : -1.5;
            currentArrow.rotation.z = i >= 0 ? 0 : Math.PI;
            currentArrow.visible = i !== 0;

            fieldCylinder.scale.set(r, 1, r);
            rings.forEach((ring, idx) => {
                ring.scale.set(r, r, 1);
                ring.material.opacity = Math.min(Math.abs(h) * 0.8, 1);
                const arrow = tangentArrows[idx];
                arrow.position.set(0, ring.position.y, r);
                arrow.rotation.y = i >= 0 ? 0 : Math.PI;
                arrow.visible = (i !== 0 && r > 0.05);
            });
        };
        inputI.oninput = update;
        inputR.oninput = update;
        update();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        const aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        camera.left = -d * aspect; camera.right = d * aspect;
        if (aspect < 1) camera.lookAt(-1.5, 0, 0); // Reajusta o foco no resize
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
