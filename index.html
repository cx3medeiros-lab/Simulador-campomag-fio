<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador de Campo Magnético H</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            display: flex; 
            flex-direction: column; /* Coloca um em cima do outro */
            height: 100vh; 
            background: #000; 
            font-family: sans-serif; 
            overflow: hidden;
        }

        /* ÁREA SUPERIOR: O SIMULADOR 3D */
        #canvas-container {
            flex: 1; /* Ocupa metade da tela ou mais */
            width: 100%;
            position: relative;
            background: #0a0a0a;
        }

        /* ÁREA INFERIOR: CONTROLES */
        #ui-panel { 
            flex: 0 0 40%; /* Ocupa exatamente 40% da altura da tela */
            background: #1a1a1a; 
            color: white; 
            padding: 15px; 
            box-sizing: border-box;
            border-top: 2px solid #333;
            overflow-y: auto; /* Permite rolar os controles se a tela for muito baixa */
        }

        .control-row { 
            display: flex; 
            align-items: center; 
            gap: 15px; 
            margin-bottom: 10px; 
        }

        .control-group { flex: 1; }

        label { display: block; font-size: 14px; color: #00d4ff; margin-bottom: 5px; }
        
        input[type=range] { 
            width: 100%; 
            height: 30px; 
            cursor: pointer; 
        }

        .formula-box {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            margin-top: 5px;
        }

        .formula { font-family: serif; font-size: 1.2em; color: #ffcc00; }
        #valor-h { font-weight: bold; color: #00ffaa; font-size: 1.2em; }
        
        #info-footer { 
            font-size: 11px; 
            color: #888; 
            text-align: center; 
            margin-top: 10px; 
        }

        /* Ajuste para telas horizontais (PC ou Celular deitado) */
        @media (orientation: landscape) {
            body { flex-direction: row; }
            #ui-panel { flex: 0 0 300px; height: 100%; border-top: none; border-right: 2px solid #333; }
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="ui-panel">
    <div class="control-row">
        <div class="control-group">
            <label id="label-i">Corrente (i): 5 A</label>
            <input type="range" id="input-i" min="-20" max="20" step="0.5" value="5">
        </div>
        <div class="control-group">
            <label id="label-r">Distância (r): 1.0 m</label>
            <input type="range" id="input-r" min="0" max="4" step="0.01" value="1">
        </div>
    </div>

    <div class="formula-box">
        <div id="formula-display" class="formula">H = i / (2πr)</div>
        <div id="valor-h">H = 0.80 A/m</div>
    </div>

    <div id="info-footer">
        Setas tangentes indicam o sentido do campo H. <br>
        R_fio = 0.12m. No interior do fio, o campo varia linearmente.
    </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
    let scene, camera, renderer, wire, currentArrow, fieldCylinder;
    const rings = [], tangentArrows = [];
    const R_FIO = 0.12;

    function init() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const aspect = container.clientWidth / container.clientHeight;
        const d = 4.5;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        wire = new THREE.Mesh(
            new THREE.CylinderGeometry(R_FIO, R_FIO, 15, 24),
            new THREE.MeshStandardMaterial({ color: 0x9c5221, metalness: 0.8, roughness: 0.3 })
        );
        scene.add(wire);

        currentArrow = new THREE.Mesh(new THREE.ConeGeometry(0.18, 0.5, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        scene.add(currentArrow);

        fieldCylinder = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 10, 32, 1, true),
            new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        scene.add(fieldCylinder);

        for (let i = 0; i < 6; i++) {
            const yPos = (i - 2.5) * 2;
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 8, 64), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            ring.rotation.x = Math.PI / 2; ring.position.y = yPos;
            scene.add(ring); rings.push(ring);

            const arrowGrp = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            stem.rotation.z = Math.PI / 2;
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            head.position.x = 0.25; head.rotation.z = -Math.PI / 2;
            arrowGrp.add(stem, head); arrowGrp.position.y = yPos;
            scene.add(arrowGrp); tangentArrows.push(arrowGrp);
        }

        setupControls();
        animate();
    }

    function setupControls() {
        const inI = document.getElementById('input-i');
        const inR = document.getElementById('input-r');
        const update = () => {
            const i = parseFloat(inI.value);
            const r = parseFloat(inR.value);
            let h = (r >= R_FIO) ? i / (2 * Math.PI * r) : (i * r) / (2 * Math.PI * (R_FIO**2));
            if (r === 0) h = 0;

            document.getElementById('formula-display').innerText = r >= R_FIO ? "H = i / (2πr)" : "H = (i·r)/(2πR²)";
            document.getElementById('label-i').innerText = `Corrente (i): ${i} A`;
            document.getElementById('label-r').innerText = `Distância (r): ${r.toFixed(2)} m`;
            document.getElementById('valor-h').innerText = `H = ${Math.abs(h).toFixed(2)} A/m`;

            currentArrow.position.y = i >= 0 ? 1.5 : -1.5;
            currentArrow.rotation.z = i >= 0 ? 0 : Math.PI;
            currentArrow.visible = i !== 0;

            fieldCylinder.scale.set(r, 1, r);
            rings.forEach((ring, idx) => {
                ring.scale.set(r, r, 1);
                ring.material.opacity = Math.min(Math.abs(h) * 0.8, 1);
                const arrow = tangentArrows[idx];
                arrow.position.set(0, ring.position.y, r);
                arrow.rotation.y = i >= 0 ? 0 : Math.PI;
                arrow.visible = (i !== 0 && r > 0.05);
            });
        };
        inI.oninput = update; inR.oninput = update;
        update();
    }
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        const container = document.getElementById('canvas-container');
        const aspect = container.clientWidth / container.clientHeight;
        const d = 4.5;
        camera.left = -d * aspect; camera.right = d * aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    init();
</script>
</body>
</html>
