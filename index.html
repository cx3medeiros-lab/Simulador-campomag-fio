<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Campo Magnético - Versão Final</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #0a0a0a; color: white; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85); padding: 20px; border-radius: 12px; border: 1px solid #444; width: 320px; pointer-events: auto; z-index: 100; }
        .control { margin-bottom: 15px; }
        label { display: block; font-size: 20px; margin-bottom: 8px; color: #ccc; }
        input[type=range] { width: 100%; cursor: pointer; }
        h3 { margin: 0 0 15px 0; font-size: 24px; color: #00d4ff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .formula { font-family: 'Times New Roman', serif; font-size: 1.8em; color: #ffcc00; text-align: center; margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; min-height: 1.2em; transition: color 0.3s; }
        #valor-h { text-align: center; font-weight: bold; color: #00aaff; font-size: 26px; margin-top: 10px; }
        
        #label-seta-i {
           position: absolute;
           top: 50%; left: 50%;
           transform: translate(20px, -10px); 
           font-family: 'Times New Roman', serif; font-style: italic;
           font-size: 30px; font-weight: bold; color: #ffff00;
           pointer-events: none;
        }
        #label-textoH-txth {
           position: absolute;
           top: 50%; left: 50%;
           transform: translate(-320px, -50px); 
           font-family: 'Times New Roman', serif; font-style: italic;
           font-size: 22px; font-weight: normal; color: #00aaff;
           pointer-events: none;
           width: 250px;           /* Ajuste esse valor para o texto quebrar onde você preferir */
        }
    </style>
</head>

<body>

<div id="ui">
    <h3>Intensidade de Campo, H</h3>
    <div class="control">
        <label id="label-i">Corrente (i): 5 A</label>
        <input type="range" id="input-i" min="-20" max="20" step="0.5" value="5">
    </div>
    <div class="control">
        <label id="label-r">Distância (r): 1.0 m</label>
        <input type="range" id="input-r" min="0" max="4" step="0.01" value="1">
    </div>
    <div id="formula-display" class="formula">H = i / (2πr)</div>
    <div id="valor-h">H = 0.80 A/m</div>
</div>

<div id="label-seta-i">i</div>
<div id="label-textoH-txth">As setas tangentes indicam o sentido do campo magnético H</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>

<script>
    let scene, camera, renderer, wire, currentArrow, fieldCylinder;
    const rings = [];
    const tangentArrows = [];
    1
    // Configurações Físicas
    const R_FIO = 0.12; // Raio do fio de cobre

    function init() {
        scene = new THREE.Scene();
        
        const aspect = window.innerWidth / window.innerHeight;
        const d = 5; 
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(4, 4, 7);
        camera.lookAt(0, 0, 0);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        // 1. Fio de Cobre Fino
        const wireGeo = new THREE.CylinderGeometry(R_FIO, R_FIO, 12, 32);
        const wireMat = new THREE.MeshStandardMaterial({ 
            color: 0x9c5221, // Cobre escuro
            metalness: 0.9, 
            roughness: 0.3,
            transparent: true,
            opacity: 0.85
        });
        wire = new THREE.Mesh(wireGeo, wireMat);
        scene.add(wire);

        // 2. Seta da Corrente (Fio)
        currentArrow = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.4, 32),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(currentArrow);

        // 3. Cilindro de Campo (Sombra Azul)
        fieldCylinder = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 8, 64, 1, true),
            new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.2, side: THREE.DoubleSide })
        );
        scene.add(fieldCylinder);

        // 4. Criação dos 6 Anéis com Setas Tangentes
        for (let i = 0; i < 6; i++) {
            const ringY = (i - 2.5) * 1.5;

            // Anel
            const ringMesh = new THREE.Mesh(
                new THREE.TorusGeometry(1, 0.015, 16, 100),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true })
            );
            ringMesh.rotation.x = Math.PI / 2;
            ringMesh.position.y = ringY;
            scene.add(ringMesh);
            rings.push(ringMesh);

            // Grupo da Seta
            const arrowGrp = new THREE.Group();
            
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.4, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true })
            );
            stem.rotation.z = Math.PI / 2; 
            arrowGrp.add(stem);

            const head = new THREE.Mesh(
                new THREE.ConeGeometry(0.07, 0.18, 8),
                new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true })
            );
            head.position.x = 0.2; 
            head.rotation.z = -Math.PI / 2;
            arrowGrp.add(head);

            arrowGrp.position.y = ringY;
            scene.add(arrowGrp);
            tangentArrows.push(arrowGrp);
        }

        setupControls();
        animate();
    }

    function setupControls() {
        const inputI = document.getElementById('input-i');
        const inputR = document.getElementById('input-r');
        const formulaDisplay = document.getElementById('formula-display');
        const valH = document.getElementById('valor-h');
        
        const update = () => {
            const i = parseFloat(inputI.value);
            const r = parseFloat(inputR.value);
            let h;

            // Lógica de Transição: Campo Externo vs Interno
            if (r >= R_FIO) {
                h = (r === 0) ? 0 : i / (2 * Math.PI * r);
                formulaDisplay.innerText = "H = i / (2πr)";
                formulaDisplay.style.color = "#ffcc00";
            } else {
                // Campo interno cresce linearmente com r
                h = (i * r) / (2 * Math.PI * Math.pow(R_FIO, 2));
                formulaDisplay.innerText = "H = (i · r) / (2πR²)";
                formulaDisplay.style.color = "#00d4ff";
            }

            const hAbs = Math.abs(h);
            document.getElementById('label-i').innerText = `Corrente (i): ${i} A`;
            document.getElementById('label-r').innerText = `Distância (r): ${r.toFixed(2)} m`;
            valH.innerText = `H = ${hAbs.toFixed(2)} A/m`;

            // Atualiza Seta da Corrente
            currentArrow.rotation.z = i >= 0 ? 0 : Math.PI;
            currentArrow.position.y = i >= 0 ? 1 : -1;
            currentArrow.visible = (i !== 0);

            // Escala do volume
            fieldCylinder.scale.set(r, 1, r);
            fieldCylinder.material.opacity = Math.min(hAbs * 0.3, 0.4);

            // Atualiza Anéis e Setas Tangentes
            rings.forEach((ringMesh, idx) => {
                ringMesh.scale.set(r, r, 1);
                ringMesh.material.opacity = Math.min(hAbs * 0.7, 1);

                const arrowGrp = tangentArrows[idx];
                // Posiciona a seta na borda Z (frente do anel) para ser tangente no eixo X
                arrowGrp.position.set(0, ringMesh.position.y, r);
                // Inverte sentido baseado no sinal da corrente
                arrowGrp.rotation.y = i >= 0 ? 0 : Math.PI;
                
                // Esconde se i=0 ou r=0
                arrowGrp.visible = (i !== 0 && r > 0.01);
                
                const op = Math.min(hAbs * 0.9, 1);
                arrowGrp.children.forEach(c => c.material.opacity = op);
            });
        };

        inputI.addEventListener('input', update);
        inputR.addEventListener('input', update);
        update();
    }

    function onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        camera.left = -d * aspect; camera.right = d * aspect;
        camera.top = d; camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.onload = init;
</script>
</body>
</html>
 
