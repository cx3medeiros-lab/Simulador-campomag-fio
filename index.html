<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulador de Campo Magnético H</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* Botão para abrir/fechar controles */
        #menu-toggle {
            position: absolute; top: 15px; left: 15px; width: 50px; height: 50px;
            background: #00d4ff; border: none; border-radius: 50%;
            color: #000; font-size: 24px; font-weight: bold; cursor: pointer;
            z-index: 1000; box-shadow: 0 0 15px rgba(0,212,255,0.5);
            display: flex; align-items: center; justify-content: center;
        }

        /* Painel de Controles (Gaveta) */
        #ui-panel { 
            position: absolute; top: 0; left: -300px; width: 280px; height: 100%;
            background: rgba(15, 15, 15, 0.95); padding: 80px 20px 20px 20px;
            transition: left 0.3s ease; border-right: 1px solid #333;
            z-index: 900; color: white; box-sizing: border-box;
            overflow-y: auto;
        }
        #ui-panel.open { left: 0; }

        .control { margin-bottom: 25px; }
        label { display: block; font-size: 18px; color: #00d4ff; margin-bottom: 10px; }
        input[type=range] { width: 100%; height: 35px; cursor: pointer; }
        
        .formula { 
            font-family: 'Times New Roman', serif; font-size: 1.6em; color: #ffcc00; 
            text-align: center; background: rgba(255,255,255,0.05); 
            padding: 15px; border-radius: 8px; margin: 15px 0;
        }
        
        #valor-h { text-align: center; font-weight: bold; color: #00ffaa; font-size: 24px; }
        #info-texto { font-size: 14px; color: #ccc; text-align: center; margin-top: 20px; line-height: 1.4; }
    </style>
</head>
<body>

<button id="menu-toggle">i</button>

<div id="ui-panel">
    <div class="control">
        <label id="label-i">Corrente (i): 5 A</label>
        <input type="range" id="input-i" min="-20" max="20" step="0.5" value="5">
    </div>
    <div class="control">
        <label id="label-r">Distância (r): 1.0 m</label>
        <input type="range" id="input-r" min="0" max="4" step="0.01" value="1">
    </div>
    <div id="formula-display" class="formula">H = i / (2πr)</div>
    <div id="valor-h">H = 0.80 A/m</div>
    <div id="info-texto">
        Ajuste os valores e feche este painel tocando no botão "i" para ver o campo em tela cheia.
    </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
    let scene, camera, renderer, wire, currentArrow, fieldCylinder;
    const rings = [], tangentArrows = [];
    const R_FIO = 0.12;

    // Lógica da Gaveta
    const btn = document.getElementById('menu-toggle');
    const panel = document.getElementById('ui-panel');
    btn.onclick = () => {
        panel.classList.toggle('open');
        btn.innerText = panel.classList.contains('open') ? '✕' : 'i';
    };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        const aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 1000);
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(5, 10, 7);
        scene.add(sun);

        // Fio
        wire = new THREE.Mesh(
            new THREE.CylinderGeometry(R_FIO, R_FIO, 15, 24),
            new THREE.MeshStandardMaterial({ color: 0x9c5221, metalness: 0.8, roughness: 0.3 })
        );
        scene.add(wire);

        // Seta i
        currentArrow = new THREE.Mesh(
            new THREE.ConeGeometry(0.18, 0.5, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(currentArrow);

        // Cilindro B
        fieldCylinder = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1, 10, 32, 1, true),
            new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.15, side: THREE.DoubleSide })
        );
        scene.add(fieldCylinder);

        for (let i = 0; i < 6; i++) {
            const yPos = (i - 2.5) * 2;
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1, 0.02, 8, 64), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            ring.rotation.x = Math.PI / 2; ring.position.y = yPos;
            scene.add(ring); rings.push(ring);

            const arrowGrp = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            stem.rotation.z = Math.PI / 2;
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true }));
            head.position.x = 0.25; head.rotation.z = -Math.PI / 2;
            arrowGrp.add(stem, head); arrowGrp.position.y = yPos;
            scene.add(arrowGrp); tangentArrows.push(arrowGrp);
        }

        setupControls();
        animate();
    }

    function setupControls() {
        const inI = document.getElementById('input-i');
        const inR = document.getElementById('input-r');
        const update = () => {
            const i = parseFloat(inI.value);
            const r = parseFloat(inR.value);
            let h = (r >= R_FIO) ? i / (2 * Math.PI * r) : (i * r) / (2 * Math.PI * (R_FIO**2));
            if (r === 0) h = 0;

            document.getElementById('formula-display').innerText = r >= R_FIO ? "H = i / (2πr)" : "H = (i·r)/(2πR²)";
            document.getElementById('label-i').innerText = `Corrente (i): ${i} A`;
            document.getElementById('label-r').innerText = `Distância (r): ${r.toFixed(2)} m`;
            document.getElementById('valor-h').innerText = `H = ${Math.abs(h).toFixed(2)} A/m`;

            currentArrow.position.y = i >= 0 ? 1.5 : -1.5;
            currentArrow.rotation.z = i >= 0 ? 0 : Math.PI;
            currentArrow.visible = i !== 0;

            fieldCylinder.scale.set(r, 1, r);
            rings.forEach((ring, idx) => {
                ring.scale.set(r, r, 1);
                ring.material.opacity = Math.min(Math.abs(h) * 0.8, 1);
                const arrow = tangentArrows[idx];
                arrow.position.set(0, ring.position.y, r);
                arrow.rotation.y = i >= 0 ? 0 : Math.PI;
                arrow.visible = (i !== 0 && r > 0.05);
            });
        };
        inI.oninput = update; inR.oninput = update;
        update();
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        const d = 5;
        camera.left = -d * camera.aspect; camera.right = d * camera.aspect;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
